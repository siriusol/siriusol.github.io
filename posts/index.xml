<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>All Posts - Ther 的博客</title>
    <link>https://blog.ther.cool/posts/</link>
    <description>All Posts | Ther 的博客</description>
    <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 06 Jun 2023 09:25:03 &#43;0800</lastBuildDate><atom:link href="https://blog.ther.cool/posts/" rel="self" type="application/rss+xml" /><item>
  <title>消息队列知识笔记</title>
  <link>https://blog.ther.cool/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</link>
  <pubDate>Tue, 06 Jun 2023 09:25:03 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</guid>
  <description><![CDATA[如何确保消息不会丢失? 现在主流的消息队列产品都提供了非常完善的消息可靠性保证机制，完全可以做到在消息传递过程中，即使发生网络中断或者硬件故障，也能确保消息的可靠传递，不丢消息。
绝大部分丢消息的原因都是由于开发者不熟悉消息队列，没有正确使用和配置消息队列导致的。
检测消息丢失的方法 如果是 IT 基础设施比较完善的公司，一般都有分布式链路追踪系统，使用类似的追踪系统可以很方便地追踪每一条消息。如果没有这样的追踪系统，这里我提供一个比较简单的方法，来检查是否有消息丢失的情况。
**我们可以利用消息队列的有序性来验证是否有消息丢失。**原理非常简单，在 Producer 端，我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的连续性。
如果没有消息丢失，Consumer 收到消息的序号必然是连续递增的，或者说收到的消息，其中的序号必然是上一条消息的序号 +1。如果检测到序号不连续，那就是丢消息了。还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。
大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到你的业务代码中，待你的系统稳定后，也方便将这部分检测的逻辑关闭或者删除。
如果是在一个分布式系统中实现这个检测方法，有几个问题需要你注意。
首先，像 Kafka 和 RocketMQ 这样的消息队列，它是不保证在 Topic 上的严格顺序的，只能保证分区上的消息是有序的，所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。
如果你的系统中 Producer 是多实例的，由于并不好协调多个 Producer 之间的发送顺序，所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识，在 Consumer 端按照每个 Producer 分别来检测序号的连续性。
Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。
疑问：怎么保存上一条消息的序号？
确保消息可靠传递 ，整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。
你可以看下这个图，一条消息从生产到消费完成这个过程，可以划分三个阶段，为了方便描述，我给每个阶段分别起了个名字。
生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。 存储阶段: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。 消费阶段: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。 1. 生产阶段]]></description>
</item><item>
  <title>Go in action-笔记</title>
  <link>https://blog.ther.cool/posts/go-in-action-%E7%AC%94%E8%AE%B0/</link>
  <pubDate>Sun, 19 Mar 2023 20:04:52 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/go-in-action-%E7%AC%94%E8%AE%B0/</guid>
  <description><![CDATA[一、介绍 Go 语言是现代的、快速的，带有一个强大的标准库。 Go 语言内置对并发的支持。 Go 语言使用接口作为代码复用的基础模块。 开发速度 编译 Go 程序时，编译器只会关注那些直接被引用的库，而不是像 Java、C 和 C++ 那样，要遍历依赖链中所有依赖的库。
因为没有从编译代码到执行代码的中间过程，用动态语言编写应用程序可以快速看到输出。代价是，动态语言不提供静态语言提供的类型安全特性，不得不经常用大量的测试套件来避免在运行的时候出现类型错误这类 bug。
并发 现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。这些语言需要 写大量的线程同步代码来利用多个核，很容易导致错误。
Go 语言对并发的支持是这门语言最重要的特性之一。goroutine 很像线程，但是它占用的内存远少于线程，使用它需要的代码更少。通道（channel）是一种内置的数据结构，可以让用户在不同的 goroutine 之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。
goroutine goroutine 是可以与其他 goroutine 并行执行的函数，同时也会与主程序（程序的入口）并行执行。在其他编程语言中，需要用线程来完成同样的事情，而在 Go 语言中会使用同一个线程来执行多个 goroutine。
例如，用户在写一个 Web 服务器，希望同时处理不同的 Web 请求，如果使用 C 或者 Java，不得不写大量的额外代码来使用线程。在 Go 语言中，net/http 库直接使用了内置的 goroutine。每个接收到的请求都自动在其自己的 goroutine 里处理。goroutine 使用的内存比线程更少，Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处理器绑定到一个操作系统线程上（下图）。这让用户的应用程序执行效率更高，而开发工作量显著减少。
如果想在执行一段代码的同时，并行去做另外一些事情，goroutine 是很好的选择。下面是一个简单的例子：
func log(msg string) { // ...这里是一些记录日志的代码 } // 代码里有些地方检测到了错误 go log(&#34;发生了可怕的事情&#34;) 关键字 go 是唯一需要去编写的代码，调度 log 函数作为独立的 goroutine 去运行，以便与其他 goroutine 并行执行。这意味着应用程序的其余部分会与记录日志并行执行，通常这种并行能让最终用户觉得性能更好。goroutine 占用的资源更少，所以常常能启动成千上万个 goroutine。]]></description>
</item><item>
  <title>定时任务框架设计</title>
  <link>https://blog.ther.cool/posts/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</link>
  <pubDate>Sun, 18 Sep 2022 20:52:42 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</guid>
  <description><![CDATA[定时任务，顾名思义，是指在某个时刻运行的任务。
使用 Go 实现一个定时任务。规定定时任务的最小间隙为 1 s，则核心代码为
for { select { case &lt;-time.NewTicker(1 * time.Second).C: // 检查当前可运行的任务并运行 case &lt;-stopped: // 终止信号 break } } 代码其实很简单，重点是怎么组织任务。
关键实体
任务
Job 任务
type Job struct { interval uint64 // 指定时间单位下的任务执行间隔 name string // 任务名称 unit timeUnit // 任务时间间隔 // err error // 任务关联的错误 // loc *time.Location lastRun time.Time // 任务上一次的执行时刻 nextRun time.Time // 任务下一次的执行时刻 f interface{} // 任务的执行函数 fParams []interface{} // 任务执行函数的参数 // lock bool // tags []string } Scheduler 调度器]]></description>
</item><item>
  <title>MySQL 数据类型</title>
  <link>https://blog.ther.cool/posts/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
  <pubDate>Sun, 07 Aug 2022 18:18:27 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
  <description><![CDATA[1. 数字类型 整型类型 MySQL 数据库支持 SQL 标准支持的整型类型：INT、SMALLINT。此外，MySQL 数据库也支持诸如 TINYINT、MEDIUMINT 和 BIGINT 整型类型（表 1 显示了各种整型所占用的存储空间及取值范围）：
类型 占用空间（字节） 最小值~最大值 [signed] 最小值~最大值 [unsigned] TINYINT 1 [-128, 127] [0, 255] SMALLINT 2 [-32768, 32767] [0, 65535] MEDIUMINT 3 [-8388608, 8388607] [0, 16777215] INT 4 [-2147483648, 2147483647] [0, 4294967295] BIGINT 8 [-9223372036854775808, 9223372036854775807] [0, 18446744073709551615] 在整型类型中，有 signed 和 unsigned 属性，其表示的是整型的取值范围，默认为 signed。在设计时不建议刻意去用 unsigned 属性，因为在做一些数据分析时，SQL 可能返回的结果并不是想要得到的结果。例如 MySQL 要求 unsigned 数值相减之后依然为 unsigned，否则就会报错。为了避免这个错误，需要对数据库参数 sql_mode 设置为 NO_UNSIGNED_SUBTRACTION，允许相减的结果为 signed。
整型类型与自增设计 整型类型最常见的就是在业务中用来表示某件物品的数量。例如上述表的销售数量，或电商中的库存数量、购买次数等。另一个常见且重要的用法是作为表的主键，即用来唯一标识一行数据。]]></description>
</item><item>
  <title>评论系统架构设计</title>
  <link>https://blog.ther.cool/posts/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
  <pubDate>Sat, 16 Jul 2022 22:05:41 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
  <description><![CDATA[]]></description>
</item><item>
  <title>Go 并发编程 内存模型</title>
  <link>https://blog.ther.cool/posts/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
  <pubDate>Sat, 09 Jul 2022 22:33:20 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
  <description><![CDATA[]]></description>
</item><item>
  <title>MySQL varchar 的最大长度</title>
  <link>https://blog.ther.cool/posts/mysql-varchar-%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</link>
  <pubDate>Thu, 03 Feb 2022 19:17:31 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/mysql-varchar-%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</guid>
  <description><![CDATA[备注：全文示例皆在 8.0.17 版本下进行。
在MySQL官方定义中，常用的 COMPACT、DYNAMIC行模式下，varchar 的最大长度并不是固定数值，取决于以下限制：
行长度限制； 编码长度限制； 存储限制。 行长度限制 MySQL 要求一行的定义长度不能超过 65535 字节（约 64 KB）。若定义长度超过这个值，则提示：
1118 - Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs 编码长度限制 每个字符的实际占据的空间与字符所使用的字符集相关。下表列举的一些例子：
字符集 每个字符占用存储空间（单位：字节） latin1 1 GBK 2 UTF8 3 UTF8MB4 4 存储限制 根据限制 1，每行最多能存储 65535 字节的数据，这包括：]]></description>
</item><item>
  <title>测试文档</title>
  <link>https://blog.ther.cool/posts/%E6%B5%8B%E8%AF%95/</link>
  <pubDate>Sat, 06 Nov 2021 17:30:31 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E6%B5%8B%E8%AF%95/</guid>
  <description><![CDATA[测试一级标题 import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, my blog!&#34;) } 网站地址 https://blog.ther.cool]]></description>
</item><item>
  <title>秒杀系统的设计</title>
  <link>https://blog.ther.cool/posts/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
  <pubDate>Sat, 21 Nov 2020 22:26:24 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
  <description><![CDATA[秒杀系统本质上就是一个满足高并发、高性能和高可用的分布式系统。
秒杀其实主要解决两个问题，一个是并发读，一个是并发写。
并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；
并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。
另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。
从一个架构师的角度来看，要想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则：
保证用户请求的数据尽量少 请求数尽量少 路径尽量短 依赖尽量少 不要有单点 秒杀的整体架构可以概括为“稳、准、快”几个关键字。
“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。
“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。
“快”，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。
所以从技术角度上看“稳、准、快”，就对应了我们架构上的高可用、一致性和高性能的要求。
高性能。 秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键。将从设计数据的动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化这 4 个方面优化。 一致性。 秒杀中商品减库存的实现方式同样关键。可想而知，有限数量的商品在同一时刻被很多倍的请求同时来减库存，减库存又分为“拍下减库存”“付款减库存”以及预扣库存等几种，在大并发更新的过程中都要保证数据的准确性。 高可用。 虽然有很多极致的优化思路，但现实中总难免出现一些考虑不到的情况，所以要保证系统的高可用和正确性，我们还要设计一个 PlanB 来兜底，以便在最坏情况发生时仍然能够从容应对。 1. 架构原则：“4 要 1 不要” 数据要尽量少 所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。
为什么“数据要尽量少”呢？因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装饰效果等等。
其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是 CPU 的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单、越小则越好。
请求数要尽量少 用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS / JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以减少请求数可以显著减少以上这些因素导致的资源消耗。
例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开，如：
https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js 这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个 URL，然后动态把这些文件合并起来一起返回。
路径要尽量短 所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。
通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。]]></description>
</item><item>
  <title>赛马问题</title>
  <link>https://blog.ther.cool/posts/%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/</link>
  <pubDate>Thu, 28 May 2020 22:50:42 &#43;0800</pubDate>
  <author>Author</author>
  <guid>https://blog.ther.cool/posts/%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/</guid>
  <description><![CDATA[问题 有 64 匹马，速度都不同，但每匹马的速度都是定值。每次只能 8 匹马进行比赛，每次比赛只能得到 8 匹马之间的快慢程度，而不是具体速度，即每赛一场最多只能知道 8 匹马的相对快慢。请问最少要比多少次才能获得最快的前 4 匹马 ？
解答 1.首先把 64 匹马随机分成 8 组，分别进行 8 次比赛，记录成绩。
2.再将每组第 1 名集合起来进行 1 次比赛。这是第 9 次比赛。
3.留下第 9 次比赛前四名的马所在的组。因为对于后 4 名的马所在的组来说，没有一匹有机会进入前四。
4.剩下的 4 组按照每组第 1 名在第 9 次比赛的成绩排序，这样按照判断原则，只剩下10匹马（如下）可能进入前 4，而第 1 组的第 1 名肯定是跑最快的马。
第一组： 1 2 3 4 第二组： 1 2 3 第三组： 1 2 第四组： 1
这样问题就变成 9 匹马找出前 3 快的。情况好的话跑 1 次可以得到，不行的话 2 次。
第一组： 2 3 4 第二组： 1 2 3 第三组： 1 2 第四组： 1]]></description>
</item></channel>
</rss>
